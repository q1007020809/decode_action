//Wed Oct 29 2025 11:31:18 GMT+0000 (Coordinated Universal Time)
//Base:<url id="cv1cref6o68qmpt26ol0" type="url" status="parsed" title="GitHub - echo094/decode-js: JS混淆代码的AST分析工具 AST analysis tool for obfuscated JS code" wc="2165">https://github.com/echo094/decode-js</url>
//Modify:<url id="cv1cref6o68qmpt26olg" type="url" status="parsed" title="GitHub - smallfawn/decode_action: 世界上本来不存在加密，加密的人多了，也便成就了解密" wc="741">https://github.com/smallfawn/decode_action</url>
(function () {
  const K = {
    GpvQv: function (Y4, Y5) {
      return Y4 === Y5;
    },
    eSjol: "未在周三的对战列表中找到您的军团。",
    YLqGZ: function (Y4, Y5) {
      return Y4 === Y5;
    },
    ExrBa: "LJNAH",
    CXgOR: "bzIgK",
    xmiNf: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    BPFxH: "lHXlT",
    vVlXa: function (Y4, Y5) {
      return Y4 === Y5;
    },
    XEqnP: "aYYYT",
    xGwOM: "内部错误：无法访问GVG模块。",
    CmAzN: function (Y4, Y5) {
      return Y4 === Y5;
    },
    HDUQn: "CAKqB",
    wQPZk: "clnDf",
    IgVCp: "[咸鱼助手][排位预测] 创建按钮时发生错误:",
    rYUCk: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    TWiZC: "wJexC",
    EqUHZ: "WVfZk",
    dXwKs: "(((.+)+)+)+$",
    ewbMK: "[咸鱼助手][排位预测]克隆数据失败:",
    USdVP: "VEpEZ",
    XcmAp: "wuIaL",
    JefhE: "LwiOy",
    tAteG: "jciam",
    AZfCC: "错误：无法加载游戏弹窗组件！",
    dRKmc: function (Y4, Y5) {
      return Y4 === Y5;
    },
    Juiti: "bWdAT",
    OWiNs: "TipsManager",
    CTHYb: "ModuleManager",
    DpuDx: "Configs",
    aSeST: function (Y4, Y5) {
      return Y4 === Y5;
    },
    smGsD: "未找到有效的战报数据！",
    ybbwy: "正在生成Excel报表...",
    DeDtO: "玩家汇总",
    pogFm: "战斗详情",
    rfxsK: "[咸鱼助手][盐场战报] 生成Excel报表时发生错误:",
    dZNRE: "生成报表失败，请查看控制台！",
    NSAPL: "[咸鱼助手][淬炼增强] 创建自定义UI时出错",
    fpjSE: "qsRLa",
    Nzfqj: "gIzrj",
    tezVD: "function *\\( *\\)",
    ISDlV: "\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)",
    tUJRH: function (Y4, Y5) {
      return Y4(Y5);
    },
    aqCkb: "init",
    XDuDh: function (Y4, Y5) {
      return Y4 + Y5;
    },
    nmnrD: "chain",
    mOqdf: "input",
    eXVTV: "MTCAQ",
    NYaxw: "VAqcD",
    Uckpy: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    PxjGJ: "UusCs",
    vjIGw: "fjhrU",
    dscGn: function (Y4) {
      return Y4();
    },
    CVLyh: "kTciS",
    yccYN: function (Y4, Y5, Y6) {
      return Y4(Y5, Y6);
    },
    vzBWq: "LegionWarReportDialog",
    EoVar: function (Y4, Y5) {
      return Y4 === Y5;
    },
    pibyi: "tpQzY",
    SBnoc: "Jicsj",
    XRxdK: "vvFnW",
    CRAnn: "index-ui",
    SjAHu: "NormalDialog",
    weEEB: "确定关闭红色淬炼提醒弹窗吗?自动淬炼过程中如果遇到红色淬炼将不再出现确认弹窗，并会自动继续洗炼",
    bCaQg: "QYFxj",
    yPTpf: "ZFkaG",
    jVJgb: function (Y4, Y5) {
      return Y4 === Y5;
    },
    gcalo: "NGxEK",
    jcjeq: "[咸鱼助手][排位预测] 注入数据模块时出错:",
    CzpcJ: function (Y4, Y5) {
      return Y4 === Y5;
    },
    xbWoe: "geiPz",
    FLkvb: "oMrMC",
    aCQsK: function (Y4, Y5) {
      return Y4 === Y5;
    },
    kJkGp: "JwmrU",
    KBUKe: function (Y4, Y5) {
      return Y4(Y5);
    },
    RKNEy: function (Y4, Y5) {
      return Y4 + Y5;
    },
    MFuSR: "return (function() ",
    WmKTx: "{}.constructor(\"return this\")( )",
    LtnPu: function (Y4) {
      return Y4();
    },
    eanvp: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    bWRcV: "gWuao",
    FsEkz: "log",
    HGAna: "warn",
    WRQcq: "info",
    PMrZi: "error",
    hGprd: "exception",
    AEtXx: "table",
    PNyJa: "trace",
    XfuWx: function (Y4, Y5) {
      return Y4 < Y5;
    },
    fNjZy: "EgJeK",
    jELCi: "qQuol",
    gNZvg: function (Y4, Y5) {
      return Y4(Y5);
    },
    keXLG: function (Y4, Y5) {
      return Y4(Y5);
    },
    vuGbC: "GVGRecordDialogNew",
    VVvGC: "BoxPanel",
    RQbPT: function (Y4, Y5) {
      return Y4 + Y5;
    },
    MTrAT: function (Y4, Y5) {
      return Y4 + Y5;
    },
    ryMbI: function (Y4, Y5) {
      return Y4 * Y5;
    },
    FyOsW: function (Y4, Y5) {
      return Y4 * Y5;
    },
    Otshm: function (Y4, Y5) {
      return Y4 + Y5;
    },
    KBpYz: function (Y4, Y5) {
      return Y4 * Y5;
    },
    lWyud: function (Y4, Y5) {
      return Y4 * Y5;
    },
    HSSpx: "HelpTextDialog",
    rvjpX: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    naljq: "gXLZR",
    rzeEF: "jWxzh",
    bxwJo: "qEsnB",
    pgleC: "感谢您的同意，助手核心功能现已启用。",
    CPdug: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    bvpoN: "KiYoP",
    cTXcy: "您已拒绝协议，核心功能将不会启用。",
    QwmWV: function (Y4, Y5) {
      return Y4 === Y5;
    },
    DoZEt: "ZrQQD",
    UcJRc: "GqmIE",
    xjDoe: "yzJRd",
    KwQkS: "luIDK",
    ywtdj: function (Y4, Y5) {
      return Y4 || Y5;
    },
    PpMfL: function (Y4, Y5) {
      return Y4 === Y5;
    },
    HkqRM: "gPcAL",
    mCvgb: "aWJzp",
    bjLtl: "咸鱼助手 用户协议",
    rvqpD: "请在使用前仔细阅读并同意以下条款：\n1.本脚本仅供学习和技术交流，禁止用于任何商业用途或游戏作弊行为\n2.使用本脚本所产生的任何风险（包括但不限于账号安全风险）均由用户自行承担，作者不承担任何责任\n3.不得利用本脚本侵犯游戏厂商的合法权益\n4.作者不对因使用或无法使用本脚本所造成的任何直接或间接损害负责。\n点击“同意”即表示您已阅读、理解并接受以上所有条款。",
    cXbSM: "ntJnh",
    YvvYN: "FJABR",
    ubITN: "[咸鱼助手] 调用协议弹窗时发生错误:",
    IBPHn: "aMeoI",
    FHTLH: function (Y4, Y5) {
      return Y4 || Y5;
    },
    XXZoJ: "[咸鱼助手][宝箱计算器] 创建按钮时发生错误:",
    ppXxf: function (Y4, Y5) {
      return Y4 - Y5;
    },
    jxMkj: function (Y4, Y5) {
      return Y4 === Y5;
    },
    mkcHb: "vACot",
    FxZtr: "debu",
    bggor: "gger",
    tMMlu: "stateObject",
    fzoQH: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    SBEdO: "tQGkU",
    avhhZ: "SAnPH",
    KRuIW: "ebszY",
    qnxTE: function (Y4, Y5) {
      return Y4 * Y5;
    },
    fspIv: function (Y4, Y5) {
      return Y4 * Y5;
    },
    IQqfs: function (Y4, Y5) {
      return Y4 * Y5;
    },
    YTBwX: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    ILIAA: "VxeGS",
    CDNoL: "KbvGc",
    FNiYo: "[咸鱼助手][罐子计算器] 计算或显示时出错:",
    xuVlp: function (Y4, Y5) {
      return Y4(Y5);
    },
    NQfmU: function (Y4, Y5) {
      return Y4 === Y5;
    },
    tuCRF: "ydVtx",
    vhuqT: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    hsIBZ: "sJFwZ",
    zHOwf: "ui_common",
    jVsuw: "BtnInfo2",
    ussLB: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    nORpf: "PdIvT",
    wbbSy: function (Y4, Y5) {
      return Y4 + Y5;
    },
    GIiMN: function (Y4, Y5) {
      return Y4 + Y5;
    },
    CifGP: function (Y4, Y5) {
      return Y4 === Y5;
    },
    fbbHZ: "inIJz",
    MsRGW: function (Y4, Y5) {
      return Y4 / Y5;
    },
    nngqA: function (Y4, Y5) {
      return Y4 - Y5;
    },
    aXOvI: function (Y4, Y5) {
      return Y4 - Y5;
    },
    BVybn: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    eNOeW: "QYIOm",
    AfFIF: "lThyz",
    IroQV: "[咸鱼助手][罐子计算器] 创建按钮时发生错误:",
    hKHlA: function (Y4, Y5) {
      return Y4 === Y5;
    },
    FZbMv: "rETTW",
    SMUFq: "MnJAf",
    uqoXW: "rTekO",
    KKMSE: "BottleRobotDialog",
    PdHJz: "fBekX",
    sAxsK: "cIHmR",
    AsEWa: "预测规则匹配失败，请检查脚本。",
    SjZtv: "FTEcJ",
    DHcXp: "档位错误",
    LeQtC: function (Y4, Y5) {
      return Y4 < Y5;
    },
    dQCpY: function (Y4, Y5) {
      return Y4 >= Y5;
    },
    OTvWE: "lRpTe",
    vbQLj: function (Y4, Y5) {
      return Y4 % Y5;
    },
    pkEYo: function (Y4, Y5) {
      return Y4 + Y5;
    },
    QOLQm: function (Y4, Y5) {
      return Y4 + Y5;
    },
    OONor: "青铜宝箱",
    PBDbx: function (Y4, Y5) {
      return Y4 * Y5;
    },
    IYjCj: "黄金宝箱",
    hMHEb: "铂金宝箱",
    DSbSd: function (Y4, Y5) {
      return Y4 + Y5;
    },
    ZWbME: function (Y4, Y5) {
      return Y4 + Y5;
    },
    WZNqe: "钻石宝箱",
    XfiyF: function (Y4, Y5) {
      return Y4(Y5);
    },
    BgHfD: function (Y4, Y5) {
      return Y4 + Y5;
    },
    VOYcr: function (Y4, Y5) {
      return Y4 === Y5;
    },
    MQOCu: "dTfsK",
    bZzqY: function (Y4, Y5) {
      return Y4 + Y5;
    },
    XTMTZ: function (Y4, Y5) {
      return Y4 * Y5;
    },
    ABdOC: function (Y4, Y5) {
      return Y4 * Y5;
    },
    tqeBH: function (Y4, Y5) {
      return Y4 + Y5;
    },
    gcHfv: function (Y4, Y5) {
      return Y4 * Y5;
    },
    tiluk: function (Y4, Y5) {
      return Y4 + Y5;
    },
    jFneM: function (Y4, Y5) {
      return Y4 + Y5;
    },
    KuEHw: function (Y4, Y5) {
      return Y4 * Y5;
    },
    HdgBd: function (Y4, Y5) {
      return Y4 === Y5;
    },
    XpkSO: "HXfvr",
    EclHp: function (Y4, Y5) {
      return Y4 + Y5;
    },
    Gszaf: function (Y4, Y5) {
      return Y4 / Y5;
    },
    pRNQJ: "function",
    QFbBX: function (Y4) {
      return Y4();
    },
    NeLIC: "qewCs",
    FCEro: "YppiF",
    vmwjd: "===== 宝箱计算结果 =====",
    plOfK: function (Y4, Y5, Y6, Y7) {
      return Y4(Y5, Y6, Y7);
    },
    zyQlN: "【全开】",
    bUOXl: "---------------------",
    vKUou: function (Y4, Y5, Y6, Y7) {
      return Y4(Y5, Y6, Y7);
    },
    LFEOM: "【不开木质】",
    Uvwyl: "【不开铂金】",
    uKdkQ: "=========@苏御=========",
    uMpav: "未知军团A",
    RHeaU: "未知军团B",
    ZMRwm: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    iPPVv: "YZqhT",
    EFwPK: "LeoMe",
    UzxxV: "PStna",
    aJNtT: "QSNql",
    WyarW: "xsxPu",
    cqCCg: "BOX",
    wumfA: "LanguageExt",
    JZNtV: "未知宝箱",
    UOSWT: "[咸鱼助手][淬炼增强] 找不到帮助按钮作为定位锚点。",
    hNgZC: function (Y4, Y5) {
      return Y4 || Y5;
    },
    bmzdQ: function (Y4, Y5) {
      return Y4 + Y5;
    },
    KtyIf: "请先在左侧切换到[周三]的战报以缓存原始数据！",
    fwpkZ: function (Y4, Y5) {
      return Y4 === Y5;
    },
    bbMlP: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    osFfn: "RPgGq",
    wBgey: "wRKdx",
    UkNsp: "TSAPZ",
    VGoiT: "luuOM",
    JvoYc: "DUrlB",
    xlkZh: "IIRYA",
    qsqhJ: "[咸鱼助手][宝箱计算器] 计算或显示时出错:",
    efYro: "CCwro",
    VkArq: "PqkJj",
    YrgZI: "OdZHP",
    SFXAm: "YHOkk",
    OdevP: "joaCd",
    rSHus: "fKCmK",
    bZlWB: function (Y4, Y5) {
      return Y4 + Y5;
    },
    xlXAs: "AhcNg",
    oOpjY: "TXzNj",
    HIXtH: function (Y4, Y5) {
      return Y4 - Y5;
    },
    nwdKY: "tUvHA",
    LaGbg: "ygKER",
    PwBkq: "ZXYFz",
    NHSNW: "pFlIj",
    UmjXm: function (Y4, Y5) {
      return Y4 + Y5;
    },
    YfcdH: function (Y4, Y5, Y6, Y7) {
      return Y4(Y5, Y6, Y7);
    },
    sdzXE: function (Y4, Y5) {
      return Y4(Y5);
    },
    ayRxx: "[咸鱼助手] 所有模块已成功注入。脚本运行中...",
    xuJGq: function (Y4, Y5) {
      return Y4 || Y5;
    },
    evJiC: "ONabI",
    pOBGG: "gAvEF",
    JKKpy: "YZfih",
    ogcWf: "YYcqp",
    uTojD: "KPebk",
    SIpVH: function (Y4, Y5) {
      return Y4 + Y5;
    },
    hLdfi: function (Y4, Y5) {
      return Y4 === Y5;
    },
    ENrAh: "gZyQn",
    TTnde: "tyEAj",
    vhrNq: "OqpJN",
    gnQMQ: "GVGRecordData",
    NPMuc: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    osbel: "xiEhG",
    ygVRQ: "ZpmlL",
    ROpfK: "[咸鱼助手][排位预测] 预测时出错:",
    NeUCc: function (Y4, Y5) {
      return Y4 || Y5;
    },
    iOmTl: "导出Excel",
    SUYlC: function (Y4, Y5) {
      return Y4 - Y5;
    },
    CVfsy: function (Y4, Y5) {
      return Y4 - Y5;
    },
    VHWgO: "while (true) {}",
    sTmek: "counter",
    aKwMc: function (Y4, Y5) {
      return Y4(Y5);
    },
    gTNXT: function (Y4, Y5) {
      return Y4 + Y5;
    },
    QeyJF: function (Y4) {
      return Y4();
    },
    XWVwj: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    WDycm: "NiXUk",
    ljkgn: "dUjPq",
    nTVTI: "dvuXF",
    LoVAI: "zKECG",
    ZlzEs: function (Y4, Y5) {
      return Y4 / Y5;
    },
    SrxKU: function (Y4, Y5) {
      return Y4 - Y5;
    },
    yhqjI: "TXCAW",
    KDxhr: "YGpFG",
    olceL: "CoZgM",
    VbFtH: "mUkNt",
    YTWtu: "Pefqn",
    MlEBB: function (Y4, Y5) {
      return Y4(Y5);
    },
    AVTvU: "4|5|3|2|1|0",
    CywHu: "[咸鱼助手] 所有目标弹窗拦截器已部署完毕。",
    jbQKX: "[咸鱼助手] 当前拦截列表:",
    pMhJc: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    RXMJu: "[咸鱼助手] 开始批量部署无感弹窗拦截...",
    HwIHM: function (Y4) {
      return Y4();
    },
    oumoa: function (Y4, Y5) {
      return Y4 === Y5;
    },
    ccXqw: "psOVr",
    yAGcU: "[咸鱼助手][盐场战报] 添加按钮时出错:",
    DWwfO: "loNdg",
    OVtZo: function (Y4, Y5) {
      return Y4 === Y5;
    },
    eNCYC: "lSFBK",
    pdeWV: "GLWqb",
    kOGWK: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    gxkBN: "eToBw",
    cJpZJ: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    CtWEO: "wEqxm",
    URwCM: function (Y4, Y5) {
      return Y4 + Y5;
    },
    GtWHP: "pcdoK",
    XdLQl: "UWWLb",
    mLepz: "xOFdb",
    ZQGYR: function (Y4, Y5) {
      return Y4 === Y5;
    },
    MvccX: "nvvGe",
    cdTKf: "LKaek",
    lsQBK: "uEplE",
    eaxCf: "lReJq",
    lzMXY: "HcKwc",
    Xeqbr: "MQnUZ",
    Lwwjz: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    CPYJg: "mSDoW",
    ARwUN: "NIzfZ",
    luuJd: "WzYBE",
    vrGIE: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    YzoKy: "kTsfW",
    DyfwP: "dHCIc",
    ESTUQ: "cjCFV",
    EFXSb: function (Y4, Y5) {
      return Y4 === Y5;
    },
    YbIau: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    aKkBD: "CkBOy",
    zqhOO: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    znPPy: "JwEEW",
    YZRuy: function (Y4, Y5) {
      return Y4 / Y5;
    },
    zslQt: function (Y4, Y5) {
      return Y4 > Y5;
    },
    oVzcp: function (Y4, Y5) {
      return Y4 - Y5;
    },
    MrHGp: "0.00",
    vnXHi: "0.00%",
    dYqxc: "玩家名称",
    xOzXc: "战力(亿)",
    LWUii: "摧毁建筑",
    MVwDn: "复活丹(估)",
    QpYkK: "!cols",
    jTNrD: function (Y4, Y5) {
      return Y4 === Y5;
    },
    xydag: "NhsbV",
    QWxar: "kmebO",
    NwYlk: function (Y4, Y5) {
      return Y4 > Y5;
    },
    vePZk: function (Y4, Y5) {
      return Y4 / Y5;
    },
    AecUN: function (Y4, Y5) {
      return Y4 - Y5;
    },
    UjaDe: "JzTfC",
    zYcms: "moWnI",
    YkjDj: "xNwiW",
    QZgeC: function (Y4, Y5) {
      return Y4 + Y5;
    },
    VHpcm: "sv-SE",
    vKJVE: "无效时间",
    QPbBw: function (Y4, Y5) {
      return Y4 + Y5;
    },
    dMZAj: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    lvLEj: "KGKwP",
    Idtse: "jYHxY",
    zftOA: function (Y4, Y5) {
      return Y4 === Y5;
    },
    cupVe: "SWVVq",
    Rtmfa: function (Y4, Y5) {
      return Y4 || Y5;
    },
    gxJev: "foEQT",
    FklfB: "SCFuS",
    cOdXq: "cWpDV",
    qwJwE: "undefined",
    KErei: function (Y4, Y5, Y6) {
      return Y4(Y5, Y6);
    },
    HLMwp: "Pfwef",
    vgYPB: "mgTRf",
    dGQMt: function (Y4, Y5) {
      return Y4 + Y5;
    },
    BCZUE: function (Y4, Y5) {
      return Y4 + Y5;
    },
    Wzarv: function (Y4, Y5) {
      return Y4 * Y5;
    },
    dUgbu: function (Y4, Y5) {
      return Y4 + Y5;
    },
    WHSCf: function (Y4, Y5) {
      return Y4 / Y5;
    },
    twCPc: function (Y4, Y5) {
      return Y4 === Y5;
    },
    BowlT: "yOqaG",
    ESJQF: "SKVKi",
    aIFkv: "QZbzJ",
    EgcqG: function (Y4, Y5) {
      return Y4 < Y5;
    },
    QDdVG: "QqDlp",
    ppyof: "rpKWh",
    LsIli: "jaKee",
    xEOAz: "玩家ID",
    uIgKe: "对手ID",
    TPtgd: "对手名称",
    RKbaJ: "战斗结果",
    PzIsb: "战斗时间",
    bxJXb: "PspQl",
    LfZXV: "JBkcH",
    BxqWH: "MainPanel",
    aARaD: function (Y4, Y5) {
      return Y4 === Y5;
    },
    NQzob: "ZoCfR",
    wxDyb: "aAXTC",
    WqDBl: function (Y4, Y5) {
      return Y4 === Y5;
    },
    uCTsU: "FtaEy",
    DfSNR: "sisjY",
    wThNF: function (Y4, Y5) {
      return Y4(Y5);
    },
    XImHT: "MPpeZ",
    DMbqm: "bCQpV",
    FsOJV: function (Y4, Y5) {
      return Y4 === Y5;
    },
    ZjRxY: "rOgCc",
    yzJqc: "dNxhZ",
    QDDpi: function (Y4, Y5) {
      return Y4 === Y5;
    },
    ZtTUD: function (Y4, Y5) {
      return Y4 === Y5;
    },
    rUKBj: "vsclC",
    XpqpD: "fbLoH",
    BQNyE: "Tsbvv",
    zypPd: "qvUiI",
    UxVmY: "data-index",
    QvRtb: "[咸鱼助手] 成功注入宝箱增强模块 (无CD/跳过所有动画)！",
    rtFzZ: "Cannot find module",
    paWKd: "Vlypg",
    uNGcU: "fhIEe",
    xZlpF: "jlhHQ",
    yUKll: "JhiAw",
    RLuyR: "CIAOW",
    NhypB: "QuenchStageUpDialog",
    ccWFd: function (Y4, Y5) {
      return Y4 === Y5;
    },
    EamUI: function (Y4, Y5) {
      return Y4 < Y5;
    },
    ceNAv: function (Y4, Y5) {
      return Y4 >= Y5;
    },
    sZKNx: function (Y4, Y5) {
      return Y4 === Y5;
    },
    ldlox: "QZoNx",
    kzYTL: "TThQH",
    jLREy: "hwOkY",
    HIXqn: "VvqhV",
    pZASC: "CoGSO",
    KeZKu: "XeeZH",
    RehIP: "TOOdE",
    UiyxB: function (Y4, Y5) {
      return Y4 || Y5;
    },
    LpSvk: function (Y4, Y5) {
      return Y4 - Y5;
    },
    XUAPD: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    NSEix: "oxwUt",
    BFErM: "QadRq",
    QPNkS: "kXuar",
    YsPxS: function (Y4, Y5) {
      return Y4 + Y5;
    },
    GhTzi: function (Y4, Y5) {
      return Y4 + Y5;
    },
    cXDOG: function (Y4, Y5, Y6) {
      return Y4(Y5, Y6);
    },
    smaYc: function (Y4, Y5) {
      return Y4 === Y5;
    },
    VOuLh: "fkRqc",
    XuAtQ: "qIhSA",
    Pyili: "tXzjK",
    wQEzm: "OGJDE",
    DjbrD: "action",
    waunv: function (Y4, Y5) {
      return Y4 * Y5;
    },
    HBChD: function (Y4, Y5) {
      return Y4 / Y5;
    },
    EpOEw: "cxtCc",
    WcCMd: "kBYwQ",
    OSDoq: "PwTRp",
    ozLwJ: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    TIeKu: "CnEQs",
    XXRRb: "wKwqH",
    ZldLv: "ljhvx",
    XTlxf: function (Y4, Y5) {
      return Y4 === Y5;
    },
    NugoT: "wuVAp",
    ARufQ: "pDNep",
    HfHxp: "ipDrY",
    GVyPU: "KxVDo",
    kPjbu: "BtnCheckBox",
    TpujO: "TextArea",
    FnQBv: "跳过红色",
    HGqZe: function (Y4, Y5) {
      return Y4 + Y5;
    },
    mjAvx: function (Y4, Y5) {
      return Y4 + Y5;
    },
    XSfWo: function (Y4, Y5) {
      return Y4 - Y5;
    },
    FCxxL: "OFDNb",
    VEefN: "bOOOR",
    vyhNT: "tnNfr",
    hRraN: "IfsPY",
    XAVPJ: "rOsHU",
    CDjla: "ytnbC",
    RJYBA: function (Y4, Y5) {
      return Y4 === Y5;
    },
    tkPYV: "BYwIe",
    GWJHI: "VoeIR",
    fUTMZ: function (Y4, Y5) {
      return Y4 * Y5;
    },
    kxMOq: "nhcoY",
    uxPmW: "bwKtR",
    SCScY: "Diwgf",
    LgyPm: function (Y4, Y5) {
      return Y4 === Y5;
    },
    SdnCq: "MBrXK",
    wvhHt: "aqReY",
    gUVWr: "QrsKX",
    donlS: "qRfmj",
    rLYyj: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    FHIRJ: "rIRin",
    kLDbb: "BhXPM",
    OzcVg: function (Y4, Y5) {
      return Y4 === Y5;
    },
    SCELS: "tvoXL",
    TCqQs: "HitSy",
    RTSaE: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    kRCSK: "kfobS",
    LyfwM: "UjfRR",
    CsnLB: "UxqCI",
    dMvpv: "1|3|2|4|0|5",
    AYaCH: "[咸鱼助手] 核心依赖 XLSX 库加载失败！战报导出功能将无法使用。",
    FYtrb: function (Y4, Y5) {
      return Y4 - Y5;
    },
    lUUCq: function (Y4, Y5) {
      return Y4 === Y5;
    },
    wqAjp: "OjVtW",
    SLMZf: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    MhBHc: "VjlWO",
    Nzzho: "cdyKp",
    xxSyb: function (Y4, Y5) {
      return Y4 === Y5;
    },
    VQMGR: "uIjUV",
    oqtYI: "yYpaF",
    OkMez: "JgiEL",
    dogVe: function (Y4, Y5) {
      return Y4 === Y5;
    },
    wcIRh: "nZXRY",
    SqsQA: "lotmX",
    lgbVg: "siuXB",
    OKrEa: "lqctu",
    rvRtq: "LiYJy",
    jQDWx: function (Y4, Y5) {
      return Y4 === Y5;
    },
    AYYrq: "tBbhT",
    rKxtr: "txpzD",
    wucak: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    FDnRB: "object",
    tHFpn: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    OVLCW: "rivAY",
    sfiKc: function (Y4, Y5) {
      return Y4 && Y5;
    },
    wJdso: function (Y4, Y5) {
      return Y4 !== Y5;
    },
    rRDKi: "CxkGn",
    Zqxeb: "IiIIc",
    HIHMg: function (Y4, Y5) {
      return Y4(Y5);
    },
    TBQqu: "CLAtm",
    HPWVf: "mTEqI",
    yKdqT: function (Y4, Y5, Y6) {
      return Y4(Y5, Y6);
    },
    PhISA: "[咸鱼助手] 脚本 v2.0 已启动，正在等待游戏环境...",
    JrXXP: function (Y4, Y5) {
      return Y4 === Y5;
    },
    lSLge: function (Y4, Y5) {
      return Y4 === Y5;
    },
    Emuga: "uFSFm",
    zIFjL: function (Y4, Y5) {
      return Y4 === Y5;
    },
    fmhcB: "ZldXv",
    NneHq: "Vvsij",
    SduLb: "木质宝箱",
    tPTHb: "TimeGiftDialog",
    JkiXe: "ActivityFestivalSpringFaceDialog24",
    VLRwr: "ActivityFestivalSpringFaceLongAnimationDialog24"
  };
  "use strict";
  console.log("[咸鱼助手] 脚本 v2.0 已启动，正在等待游戏环境...");
  let q = false;
  let I = false;
  if (typeof XLSX === "undefined") {
    {
      console.error("[咸鱼助手] 核心依赖 XLSX 库加载失败！战报导出功能将无法使用。");
    }
  } else {
    {
      console.log("[咸鱼助手] XLSX 库已加载，版本: " + XLSX.version);
    }
  }
  const n = {
    showUserAgreementDialog: function () {
      {
        try {
          {
            const Y8 = unsafeWindow.__require("index-ui").SHOW_SIMPLE_DIALOG;
            const Y9 = unsafeWindow.__require("NormalDialog");
            const YY = unsafeWindow.__require("TipsManager");
            if (!Y8 || !Y9) {
              {
                YY.SHOW_TIP("错误：无法加载游戏弹窗组件！");
                return;
              }
            }
            const Yj = {
              title: "咸鱼助手 用户协议",
              content: "请在使用前仔细阅读并同意以下条款：\n1.本脚本仅供学习和技术交流，禁止用于任何商业用途或游戏作弊行为\n2.使用本脚本所产生的任何风险（包括但不限于账号安全风险）均由用户自行承担，作者不承担任何责任\n3.不得利用本脚本侵犯游戏厂商的合法权益\n4.作者不对因使用或无法使用本脚本所造成的任何直接或间接损害负责。\n点击“同意”即表示您已阅读、理解并接受以上所有条款。",
              [Y9.NormalDialog.OP_BUTTON_MODE]: Y9.NormalButtonMode.TwoButton,
              [Y9.NormalDialog.OP_BTN_YES_TITLE]: "同意",
              [Y9.NormalDialog.OP_BTN_NO_TITLE]: "拒绝",
              hook: function (YL) {
                {
                  if (YL) {
                    {
                      q = true;
                      YY.SHOW_TIP("感谢您的同意，助手核心功能现已启用。");
                    }
                  } else {
                    {
                      YY.SHOW_TIP("您已拒绝协议，核心功能将不会启用。");
                    }
                  }
                }
              }
            };
            Y8(Y9.NormalDialog, Yj);
          }
        } catch (Ys) {
          console.error("[咸鱼助手] 调用协议弹窗时发生错误:", Ys);
        }
      }
    },
    patchPanel: function (Y6) {
      {
        const Y8 = Y6.prototype.onShow;
        Y6.prototype.onShow = function () {
          {
            Y8.apply(this, arguments);
            if (I || q) {
              return;
            }
            I = true;
            n.showUserAgreementDialog();
          }
        };
        console.log("[咸鱼助手] 成功注入到 <" + Y6.name + ">，协议弹窗已准备就绪。");
      }
    }
  };
  const k = {
    GOLD: 160,
    SILVER: 100,
    COPPER: 40
  };
  const E = {
    GOLD: 190,
    SILVER: 110,
    COPPER: 48
  };
  const M = {
    GUARANTEED: k,
    ESTIMATED: E
  };
  const i = {
    BOTTLE_VALUES: M,
    patchPanel: function (Y6) {
      {
        const Y9 = Y6.prototype.onShow;
        Y6.prototype.onShow = function () {
          {
            Y9.apply(this, arguments);
            if (!q) {
              return;
            }
            if (this._calculateButton_bottle) {
              return;
            }
            try {
              {
                const YL = unsafeWindow.fgui.UIPackage.createObject("ui_common", "BtnInfo2").asButton;
                const Ys = this.ui;
                const Yd = this.ui.m_btnHelp;
                Yd ? YL.setPosition(Yd.x, Yd.y + Yd.height + 10) : YL.setXY((Ys.width - YL.width) / 2, (Ys.height - YL.height) / 2);
                YL.onClick(() => {
                  {
                    try {
                      {
                        let Yz = this.bottleComps[0].obtainCnt || 0;
                        let YB = this.bottleComps[1].obtainCnt || 0;
                        let YW = this.bottleComps[2].obtainCnt || 0;
                        const YS = Yz * i.BOTTLE_VALUES.GUARANTEED.GOLD + YB * i.BOTTLE_VALUES.GUARANTEED.SILVER + YW * i.BOTTLE_VALUES.GUARANTEED.COPPER;
                        const YR = Yz * i.BOTTLE_VALUES.ESTIMATED.GOLD + YB * i.BOTTLE_VALUES.ESTIMATED.SILVER + YW * i.BOTTLE_VALUES.ESTIMATED.COPPER;
                        const YX = "=====罐子计算结果=====\n\n金罐子: " + Yz + " 个\n银罐子: " + YB + " 个\n铜罐子: " + YW + " 个\n\n平均预估: " + YR.toLocaleString() + " 金砖\n保底金砖: " + YS.toLocaleString() + " 金砖\n\n========@苏御=========";
                        const Yx = unsafeWindow.__require("index-ui");
                        const YH = unsafeWindow.__require("HelpTextDialog");
                        const Yc = YH.HelpTextDialog;
                        const YF = {
                          [Yc.OP_OBJ]: this._calculateButton_bottle,
                          [Yc.OP_CONTENT]: YX
                        };
                        const YK = YF;
                        Yx.SHOW_PROXY_OVER(Yc, YK);
                      }
                    } catch (Ye) {
                      console.error("[咸鱼助手][罐子计算器] 计算或显示时出错:", Ye);
                      unsafeWindow.__require("TipsManager").SHOW_TIP("计算出错");
                    }
                  }
                });
                Ys.addChild(YL);
                this._calculateButton_bottle = YL;
              }
            } catch (Yl) {
              {
                console.error("[咸鱼助手][罐子计算器] 创建按钮时发生错误:", Yl);
              }
            }
          }
        };
        const YY = Y6.prototype.onHide;
        Y6.prototype.onHide = function () {
          {
            if (this._calculateButton_bottle) {
              {
                this._calculateButton_bottle.dispose();
                this._calculateButton_bottle = null;
              }
            }
            YY.apply(this, arguments);
          }
        };
        console.log("[咸鱼助手] 成功注入罐子计算器到 <" + Y6.name + ">！");
      }
    }
  };
  const Q = {
    name: "木质宝箱",
    points: 1
  };
  const v = {
    name: "青铜宝箱",
    points: 10
  };
  const h = {
    name: "黄金宝箱",
    points: 20
  };
  const P = {
    name: "铂金宝箱",
    points: 50
  };
  const p = {
    name: "钻石宝箱",
    points: 0
  };
  const N = {
    "2001": Q,
    "2002": v,
    "2003": h,
    "2004": P,
    "2005": p
  };
  const u = {
    values: [10, 20, 30, 40, 80, 100, 70, 50, 100],
    boxes: ["青铜宝箱", "青铜宝箱", "黄金宝箱", "铂金宝箱", "铂金宝箱", "铂金宝箱", "黄金宝箱", "铂金宝箱", "钻石宝箱"]
  };
  const V = {
    BOX_CONFIG: N,
    STAGES_CONFIG: u,
    calculateRecursive: function (Y6, Y7, Y8, Y9, YY = 0, Yj = 0) {
      {
        const {
          values: Yd,
          boxes: Yy
        } = this.STAGES_CONFIG;
        let Ym = Yy.findIndex((YS, YR) => YS === Y8 && Yd[YR] === Y7);
        if (Ym === -1) {
          return {
            error: "档位错误"
          };
        }
        if (Y6 < Y7) {
          return {
            total_point_value: Yj,
            total_diamond_boxes: YY,
            final_stage_info: "积分值：" + Y6 + "/" + Y7 + " (" + Y8 + ")"
          };
        }
        let Yz = {
          "青铜宝箱": 0,
          "黄金宝箱": 0,
          "铂金宝箱": 0,
          "钻石宝箱": 0
        };
        let YB = Y6;
        while (YB >= Yd[Ym]) {
          YB -= Yd[Ym];
          Yz[Yy[Ym]]++;
          Ym = (Ym + 1) % Yd.length;
        }
        let YW = Yz["青铜宝箱"] * this.getPointsByName("青铜宝箱") + Yz["黄金宝箱"] * this.getPointsByName("黄金宝箱") + (Y9 ? 0 : Yz["铂金宝箱"] * this.getPointsByName("铂金宝箱"));
        return this.calculateRecursive(YB + YW, Yd[Ym], Yy[Ym], Y9, YY + Yz["钻石宝箱"], Yj + YW);
      }
    },
    calculate: function (Y6) {
      {
        const {
          wood_chest: Y7,
          bronze_chest: Y8,
          gold_chest: Y9,
          platinum_chest: YY,
          current_points: Yj,
          required_points: YG,
          chest_type: YL
        } = Y6;
        const Ys = Y7 * 1 + Y8 * 10 + Y9 * 20 + YY * 50 + Yj;
        const Yd = Y8 * 10 + Y9 * 20 + YY * 50 + Yj;
        const Yy = Y7 * 1 + Y8 * 10 + Y9 * 20 + Yj;
        const Ym = this.calculateRecursive(Ys, YG, YL, false);
        const Yl = this.calculateRecursive(Yd, YG, YL, false);
        const Yz = this.calculateRecursive(Yy, YG, YL, true);
        const YB = {
          res1: Ym,
          res2: Yl,
          res3: Yz,
          p_all: Ys,
          p_no_wood: Yd,
          p_no_plat: Yy
        };
        return this.formatResult(YB);
      }
    },
    formatResult: function (Y6) {
      {
        const Y8 = (Y9, YY, Yj) => {
          {
            if (Yj.error) {
              return Y9 + "\n计算出错: " + Yj.error;
            }
            const YG = YY + Yj.total_point_value;
            return ["" + Y9, "宝箱裸分: " + YY.toLocaleString(), "宝箱总分: " + YG.toLocaleString() + "分", "宝箱轮数: " + (YG / 8000).toFixed(2) + "轮 (下轮需: " + (8000 - YG % 8000).toLocaleString() + "分)", Yj.final_stage_info, "奖励钻石宝箱: " + Yj.total_diamond_boxes + "个"].join("\n");
          }
        };
        return ["===== 宝箱计算结果 =====", Y8("【全开】", Y6.p_all, Y6.res1), "---------------------", Y8("【不开木质】", Y6.p_no_wood, Y6.res2), "---------------------", Y8("【不开铂金】", Y6.p_no_plat, Y6.res3), "=========@苏御========="].join("\n\n");
      }
    },
    getPointsByName: function (Y6) {
      {
        for (const Y8 in this.BOX_CONFIG) if (this.BOX_CONFIG[Y8].name === Y6) {
          return this.BOX_CONFIG[Y8].points;
        }
        return 0;
      }
    },
    patchPanel: function (Y6) {
      {
        const Y9 = Y6.prototype.onShow;
        Y6.prototype.onShow = function () {
          {
            Y9.apply(this, arguments);
            if (!q) {
              return;
            }
            if (this._calculateButton_box) {
              return;
            }
            try {
              {
                const YL = unsafeWindow.fgui.UIPackage.createObject("ui_common", "BtnInfo2").asButton;
                const Ys = this.ui;
                const Yd = this.ui.m_quesHelp;
                if (Yd) {
                  {
                    YL.setPosition(Yd.x + Yd.width + 10, Yd.y);
                  }
                } else {
                  {
                    YL.setPosition(20, Ys.height - YL.height - 20);
                  }
                }
                YL.onClick(() => {
                  {
                    try {
                      {
                        const Yz = unsafeWindow.__require("ModuleManager").GET_MODULE(unsafeWindow.__require("Configs").ModuleType.BOX);
                        Yz.syncRewardConf();
                        const YB = Yz.curBoxPointLastRewardConf;
                        const YW = {
                          wood_chest: unsafeWindow.ROLE.getItemQuantity(2001),
                          bronze_chest: unsafeWindow.ROLE.getItemQuantity(2002),
                          gold_chest: unsafeWindow.ROLE.getItemQuantity(2003),
                          platinum_chest: unsafeWindow.ROLE.getItemQuantity(2004),
                          current_points: Yz.boxRenderPoint,
                          required_points: YB ? YB.limit : 0,
                          chest_type: YB ? unsafeWindow.__require("LanguageExt").GET_CONTENT(YB.description) || "未知宝箱" : "无"
                        };
                        const YS = V.calculate(YW);
                        const YR = unsafeWindow.__require("index-ui");
                        const YX = unsafeWindow.__require("HelpTextDialog");
                        const Yx = YX.HelpTextDialog;
                        const YH = {
                          [Yx.OP_OBJ]: this._calculateButton_box,
                          [Yx.OP_CONTENT]: YS
                        };
                        const Yc = YH;
                        YR.SHOW_PROXY_OVER(Yx, Yc);
                      }
                    } catch (YK) {
                      console.error("[咸鱼助手][宝箱计算器] 计算或显示时出错:", YK);
                      unsafeWindow.__require("TipsManager").SHOW_TIP("计算出错");
                    }
                  }
                });
                Ys.addChild(YL);
                this._calculateButton_box = YL;
              }
            } catch (Yz) {
              {
                console.error("[咸鱼助手][宝箱计算器] 创建按钮时发生错误:", Yz);
              }
            }
          }
        };
        const YY = Y6.prototype.onHide;
        Y6.prototype.onHide = function () {
          {
            if (this._calculateButton_box) {
              {
                this._calculateButton_box.dispose();
                this._calculateButton_box = null;
              }
            }
            YY.apply(this, arguments);
          }
        };
        console.log("[咸鱼助手] 成功注入宝箱计算器到 <" + Y6.name + ">！");
      }
    }
  };
  const Z = {
    rawMatchDataCache: {},
    dataModulePatched: false,
    patchDataModule: function () {
      {
        if (this.dataModulePatched) {
          return;
        }
        try {
          {
            const Y8 = unsafeWindow.__require("GVGRecordData");
            if (!Y8 || !Y8.GVGRecordData) {
              return;
            }
            const Y9 = Y8.GVGRecordData;
            const YY = Y9.prototype.unpackMatchDetails;
            if (!YY) {
              return;
            }
            Y9.prototype.unpackMatchDetails = function (Yj, YG) {
              {
                try {
                  {
                    const Yd = JSON.parse(JSON.stringify(YG));
                    Z.rawMatchDataCache[Yj] = Yd;
                  }
                } catch (Yy) {
                  {
                    console.error("[咸鱼助手][排位预测]克隆数据失败:", Yy);
                    Z.rawMatchDataCache[Yj] = YG;
                  }
                }
                return YY.apply(this, arguments);
              }
            };
            this.dataModulePatched = true;
          }
        } catch (YG) {
          console.error("[咸鱼助手][排位预测] 注入数据模块时出错:", YG);
        }
      }
    },
    patchPanel: function (Y6) {
      {
        const Y8 = Y6.prototype.onShown;
        Y6.prototype.onShown = function () {
          {
            Y8.apply(this, arguments);
            if (!q) {
              return;
            }
            Z.patchDataModule();
            if (this._predictButton_gvg) {
              return;
            }
            try {
              {
                const YL = unsafeWindow.fgui.UIPackage.createObject("ui_common", "BtnInfo2").asButton;
                const Ys = this.ui;
                const Yd = this.ui.m_score;
                const Yy = 20;
                if (Yd) {
                  YL.setPosition(Yy, Yd.y - (YL.height - Yd.height) / 2);
                } else {
                  {
                    YL.setPosition(Yy, 80);
                  }
                }
                YL.onClick(this.predictGVGMatches.bind(this, YL));
                Ys.addChild(YL);
                this._predictButton_gvg = YL;
              }
            } catch (Yz) {
              {
                console.error("[咸鱼助手][排位预测] 创建按钮时发生错误:", Yz);
              }
            }
          }
        };
        Y6.prototype.predictGVGMatches = function (YY) {
          {
            const YG = unsafeWindow.__require("TipsManager");
            try {
              {
                const YL = this._module;
                if (!YL) {
                  {
                    YG.SHOW_TIP("内部错误：无法访问GVG模块。");
                    return;
                  }
                }
                const Ys = Z.rawMatchDataCache[3];
                if (!Ys || !Ys.matchList || Ys.matchList.length === 0) {
                  {
                    YG.SHOW_TIP("请先在左侧切换到[周三]的战报以缓存原始数据！");
                    return;
                  }
                }
                const Yd = YL.arenaData.selfLegion.name;
                const Yy = Ys.matchList;
                const Ym = [];
                const Yl = [];
                Yy.forEach(Yn => {
                  {
                    Ym.push(Yn.leftLegion.legionName);
                    Yl.push(Yn.rightLegion.legionName);
                  }
                });
                let Yz = null;
                let YB = Ym.indexOf(Yd);
                if (YB !== -1) {
                  Yz = "A" + (YB + 1);
                } else {
                  {
                    YB = Yl.indexOf(Yd);
                    if (YB !== -1) {
                      Yz = "B" + (YB + 1);
                    }
                  }
                }
                if (!Yz) {
                  {
                    YG.SHOW_TIP("未在周三的对战列表中找到您的军团。");
                    return;
                  }
                }
                const YS = {
                  A1: "B3",
                  A2: "B1",
                  A3: "B2",
                  A4: "B5",
                  A5: "B4",
                  B1: "A2",
                  B2: "A3",
                  B3: "A1",
                  B4: "A5",
                  B5: "A4"
                };
                const YX = {
                  A1: "B2",
                  A2: "B3",
                  A3: "B1",
                  A4: "A5",
                  A5: "A4",
                  B1: "A3",
                  B2: "A1",
                  B3: "A2",
                  B4: "B5",
                  B5: "B4"
                };
                const Yx = YS[Yz];
                const YH = YX[Yz];
                if (!Yx || !YH) {
                  {
                    YG.SHOW_TIP("预测规则匹配失败，请检查脚本。");
                    return;
                  }
                }
                const Yc = YM => {
                  {
                    const Yv = parseInt(YM.substring(1)) - 1;
                    if (YM.startsWith("A")) {
                      return Ym[Yv] || "未知军团A";
                    }
                    return Yl[Yv] || "未知军团B";
                  }
                };
                const YF = Yc(Yx);
                const YK = Yc(YH);
                const Ye = "=====排位预测=====\n\n当前俱乐部: " + Yd + "\n---------------------\n\n周四对手预测:\n" + Yd + " VS " + YF + "\n---------------------\n周五对手预测:\n" + Yd + " VS " + YK + "\n\n=========@苏御=========";
                const Yf = unsafeWindow.__require("index-ui");
                const Yo = unsafeWindow.__require("HelpTextDialog");
                const YC = {
                  [Yo.HelpTextDialog.OP_OBJ]: YY,
                  [Yo.HelpTextDialog.OP_CONTENT]: Ye
                };
                const Yg = YC;
                Yf.SHOW_PROXY_OVER(Yo.HelpTextDialog, Yg);
              }
            } catch (Yi) {
              console.error("[咸鱼助手][排位预测] 预测时出错:", Yi);
              YG.SHOW_TIP("预测出错，请查看控制台");
            }
          }
        };
        const Y9 = Y6.prototype.onHide;
        Y6.prototype.onHide = function () {
          {
            if (this._predictButton_gvg) {
              {
                this._predictButton_gvg.dispose();
                this._predictButton_gvg = null;
              }
            }
            Y9.apply(this, arguments);
          }
        };
        console.log("[咸鱼助手] 成功注入排位预测器到 <" + Y6.name + ">！");
      }
    }
  };
  const a = {
    patchDialog: function (Y6) {
      {
        const Y9 = Y6.prototype.onShown;
        Y6.prototype.onShown = function () {
          {
            Y9.apply(this, arguments);
            if (!q || typeof XLSX === "undefined") {
              return;
            }
            setTimeout(() => {
              {
                if (this._customExportButton) {
                  return;
                }
                try {
                  {
                    const YL = this.ui;
                    const Ys = YL.m_btnBest;
                    if (!YL || !Ys || !Ys.node.active) {
                      return;
                    }
                    const Yd = Ys.packageItem.owner;
                    const Yy = Ys.packageItem.name;
                    const Ym = Yd.createObject(Yy);
                    if (!Ym) {
                      return;
                    }
                    const Yl = Ym.asButton;
                    Yl.setSize(Ys.width, Ys.height);
                    Yl.title = "导出Excel";
                    const Yz = 20;
                    Yl.setPosition(Ys.x - Yl.width - Yz, Ys.y);
                    Yl.onClick(this.handleExportToExcel.bind(this));
                    Ys.parent.addChild(Yl);
                    this._customExportButton = Yl;
                  }
                } catch (YW) {
                  {
                    console.error("[咸鱼助手][盐场战报] 添加按钮时出错:", YW);
                  }
                }
              }
            }, 100);
          }
        };
        const YY = Y6.prototype.onHide;
        Y6.prototype.onHide = function () {
          {
            if (this._customExportButton) {
              {
                this._customExportButton.dispose();
                this._customExportButton = null;
              }
            }
            YY.apply(this, arguments);
          }
        };
        Y6.prototype.handleExportToExcel = function () {
          {
            const Ys = unsafeWindow.__require("TipsManager");
            try {
              {
                const Yd = unsafeWindow.__require("ModuleManager");
                const Yy = unsafeWindow.__require("Configs");
                const Ym = Yd.GET_MODULE(Yy.ModuleType.LEGION_WAR);
                const Yl = Ym?.["reportData"]?.["details"]?.["roleDetailsList"];
                if (!Yl || Yl.length === 0) {
                  {
                    Ys.SHOW_TIP("未找到有效的战报数据！");
                    return;
                  }
                }
                Ys.SHOW_TIP("正在生成Excel报表...");
                const Yz = XLSX.utils.book_new();
                const YB = this.createPlayerSummarySheet(Yl);
                const YW = this.createBattleDetailsSheet(Yl, Ym);
                XLSX.utils.book_append_sheet(Yz, YB, "玩家汇总");
                XLSX.utils.book_append_sheet(Yz, YW, "战斗详情");
                const YS = this.gameDate.replace(/\s+/g, "").replace(/\//g, "-");
                const YR = "军团战报_" + YS + ".xlsx";
                XLSX.writeFile(Yz, YR);
              }
            } catch (YH) {
              console.error("[咸鱼助手][盐场战报] 生成Excel报表时发生错误:", YH);
              Ys.SHOW_TIP("生成报表失败，请查看控制台！");
            }
          }
        };
        Y6.prototype.createPlayerSummarySheet = function (Yj) {
          {
            const YL = ["ID", "玩家名称", "战力(亿)", "胜场", "负场", "胜率", "摧毁建筑", "复活丹(估)"];
            const Ys = [...Yj].sort((Yc, YF) => (YF.winCnt || 0) - (Yc.winCnt || 0) || (Yc.loseCnt || 0) - (YF.loseCnt || 0));
            const Yd = Ys.map(Yc => {
              {
                const Ye = Yc.winCnt || 0;
                const Yf = Yc.loseCnt || 0;
                const Yo = Ye + Yf;
                return [Yc.roleId, Yc.name, (Yc.power || 0) / 100000000, Ye, Yf, Yo > 0 ? Ye / Yo : 0, Yc.buildingCnt || 0, Math.max(0, Yf - 6)];
              }
            });
            const Yy = ["总计", null, null, 0, 0, 0, 0, 0];
            Yd.forEach(Yc => {
              Yy[3] += Yc[3];
              Yy[4] += Yc[4];
              Yy[6] += Yc[6];
              Yy[7] += Yc[7];
            });
            const Ym = Yy[3] + Yy[4];
            Yy[5] = Ym > 0 ? Yy[3] / Ym : 0;
            Yd.push(Yy);
            const Yl = XLSX.utils.aoa_to_sheet([YL, ...Yd]);
            const Yz = {
              wch: 15
            };
            const YB = {
              wch: 20
            };
            const YW = {
              wch: 15
            };
            const YS = {
              wch: 10
            };
            const YR = {
              wch: 10
            };
            const YX = {
              wch: 10
            };
            const Yx = {
              wch: 12
            };
            const YH = {
              wch: 12
            };
            Yl["!cols"] = [Yz, YB, YW, YS, YR, YX, Yx, YH];
            Yd.forEach((Yc, YF) => {
              {
                const Ye = YF + 2;
                if (Yl["C" + Ye]) {
                  Yl["C" + Ye].z = "0.00";
                }
                if (Yl["F" + Ye]) {
                  Yl["F" + Ye].z = "0.00%";
                }
              }
            });
            return Yl;
          }
        };
        Y6.prototype.createBattleDetailsSheet = function (Yj, YG) {
          {
            const Yd = ["玩家ID", "玩家名称", "对手ID", "对手名称", "战斗结果", "战斗时间"];
            let Yy = [];
            Yj.forEach(Yx => {
              {
                (Yx.targetRoleList || []).forEach(YF => {
                  {
                    const Ye = YF.targetRoleInfo || {};
                    let Yf = "未知";
                    if (YF.timestamp) {
                      try {
                        {
                          Yf = new Date(YF.timestamp * 1000).toLocaleString("sv-SE");
                        }
                      } catch (YC) {
                        Yf = "无效时间";
                      }
                    }
                    Yy.push({
                      rid: Yx.roleId,
                      rname: Yx.name || YG.getAnonymousRoleName(Yx.roleId),
                      tid: Ye.roleId,
                      tname: Ye.name || YG.getAnonymousRoleName(Ye.roleId),
                      res: YF.winFlag ? "胜利" : "失败",
                      ts: YF.timestamp || 0,
                      time: Yf
                    });
                  }
                });
              }
            });
            Yy.sort((Yx, YH) => YH.ts - Yx.ts);
            const Ym = Yy.map(Yx => [Yx.rid, Yx.rname, Yx.tid, Yx.tname, Yx.res, Yx.time]);
            const Yl = XLSX.utils.aoa_to_sheet([Yd, ...Ym]);
            const Yz = {
              wch: 15
            };
            const YB = {
              wch: 20
            };
            const YW = {
              wch: 15
            };
            const YS = {
              wch: 20
            };
            const YR = {
              wch: 10
            };
            const YX = {
              wch: 20
            };
            Yl["!cols"] = [Yz, YB, YW, YS, YR, YX];
            return Yl;
          }
        };
        console.log("[咸鱼助手] 成功注入盐场战报导出器到 <" + Y6.name + ">！");
      }
    }
  };
  const O = {
    patched: false,
    patchModule: function () {
      {
        if (this.patched || !q) {
          return;
        }
        try {
          {
            const Y9 = unsafeWindow.__require("ModuleManager");
            const YY = unsafeWindow.__require("Configs");
            const Yj = unsafeWindow.__require("data-index");
            const YG = unsafeWindow.__require("TipsManager");
            const YL = unsafeWindow.__require("Configs").ItemConf;
            const Ys = unsafeWindow.__require("LanguageExt");
            const Yd = Y9.GET_MODULE(YY.ModuleType.BOX);
            if (!Yd) {
              return;
            }
            Yd.sendOpenBox = function (Yy, Ym) {
              {
                const YB = this;
                return new Promise(function (YW) {
                  {
                    const YX = {
                      itemId: Yy,
                      number: Ym
                    };
                    Yj.ItemService.openBox(YX).then(function (Yx) {
                      {
                        if (Yx.code) {
                          {
                            YW(null);
                          }
                        } else {
                          {
                            YB.syncBoxPoint();
                            const Yf = YL.getById(Yy);
                            const Yo = Yf ? Ys.GET_CONTENT(Yf.name) : "宝箱";
                            YG.SHOW_TIP("成功开启 " + Ym + " 个" + Yo);
                            YW(null);
                          }
                        }
                      }
                    });
                  }
                });
              }
            };
            this.patched = true;
            console.log("[咸鱼助手] 成功注入宝箱增强模块 (无CD/跳过所有动画)！");
          }
        } catch (Yy) {}
      }
    }
  };
  const w = {
    patchDialog: function (Y6) {
      {
        Y6.prototype._isSkipRed = false;
        Y6.prototype._skipRedCheckbox = null;
        Y6.prototype._skipRedLabel = null;
        const Y9 = Y6.prototype._changeAutoState;
        Y6.prototype._changeAutoState = function () {
          {
            Y9.apply(this, arguments);
            if (this._isOpenAuto) {
              {
                if (!this._skipRedCheckbox) {
                  {
                    try {
                      {
                        const Ym = this.ui.m_btnHelp;
                        if (!Ym) {
                          {
                            console.error("[咸鱼助手][淬炼增强] 找不到帮助按钮作为定位锚点。");
                            return;
                          }
                        }
                        const Yl = unsafeWindow.fgui.UIPackage.createObject("ui_common", "BtnCheckBox").asButton;
                        Yl.selected = this._isSkipRed;
                        const Yz = unsafeWindow.fgui.UIPackage.createObject("ui_common", "TextArea").asButton;
                        Yz.text = "跳过红色";
                        Yz.fontSize = 24;
                        Yz.color = new unsafeWindow.cc.Color(155, 92, 46);
                        const YB = 30;
                        const YW = 0;
                        Yl.setPosition(YB, Ym.y + (Ym.height - Yl.height) / 2);
                        Yz.setPosition(Yl.x + Yl.width + YW, Ym.y + 12 + (Ym.height - Yl.height) / 2);
                        Yl.onClick(() => {
                          {
                            if (Yl.selected) {
                              {
                                const Yx = unsafeWindow.__require("index-ui");
                                const YH = unsafeWindow.__require("NormalDialog");
                                Yx.SHOW_SIMPLE_DIALOG(YH.NormalDialog, {
                                  content: "确定关闭红色淬炼提醒弹窗吗?自动淬炼过程中如果遇到红色淬炼将不再出现确认弹窗，并会自动继续洗炼",
                                  hook: Yc => {
                                    {
                                      this._isSkipRed = Yc;
                                      Yl.selected = Yc;
                                    }
                                  }
                                });
                              }
                            } else {
                              this._isSkipRed = false;
                            }
                          }
                        });
                        this.ui.addChild(Yl);
                        this.ui.addChild(Yz);
                        this._skipRedCheckbox = Yl;
                        this._skipRedLabel = Yz;
                      }
                    } catch (YR) {
                      console.error("[咸鱼助手][淬炼增强] 创建自定义UI时出错", YR);
                    }
                  }
                }
              }
            } else {
              this._skipRedCheckbox && (this._skipRedCheckbox.dispose(), this._skipRedCheckbox = null);
              this._skipRedLabel && (this._skipRedLabel.dispose(), this._skipRedLabel = null);
              this._isSkipRed = false;
            }
          }
        };
        const YY = Y6.prototype.onHide;
        Y6.prototype.onHide = function () {
          {
            this._skipRedCheckbox && (this._skipRedCheckbox.dispose(), this._skipRedCheckbox = null);
            if (this._skipRedLabel) {
              {
                this._skipRedLabel.dispose();
                this._skipRedLabel = null;
              }
            }
            this._isSkipRed = false;
            YY.apply(this, arguments);
          }
        };
        const Yj = Y6.prototype._checkQuenchConfirm;
        Y6.prototype._checkQuenchConfirm = function () {
          {
            if (q) {
              {
                const Ys = this._equipInfo.quenches;
                let Yd = false;
                this._needConfrimQuenches.length = 0;
                const Yy = 5;
                const Ym = 6;
                Ys.forEach((Yl, Yz) => {
                  {
                    if (this._locks.has(Yz)) {
                      return;
                    }
                    let YS = false;
                    if (Yl.colorId === Yy && !this._isSkipOrange) {
                      {
                        YS = true;
                      }
                    }
                    if (Yl.colorId === Ym && !this._isSkipRed) {
                      {
                        YS = true;
                      }
                    }
                    YS && (Yd = true, this._needConfrimQuenches.push(Yl));
                  }
                });
                return Yd;
              }
            }
            return Yj.apply(this, arguments);
          }
        };
        console.log("[咸鱼助手] 成功注入淬炼增强模块到 <" + Y6.name + ">！");
      }
    }
  };
  const b = {
    DIALOGS_TO_BLOCK: ["TimeGiftDialog", "ActivityFestivalSpringFaceDialog24", "ActivityFestivalSpringFaceLongAnimationDialog24"],
    isPatched: false,
    patchDialog: function (Y6) {
      {
        try {
          {
            const Y9 = unsafeWindow.__require(Y6);
            if (!Y9 || !Y9[Y6]) {
              {
                console.warn("[咸鱼助手][拦截器] 警告：无法找到模块 " + Y6 + "，已跳过。");
                return;
              }
            }
            const YY = Y9[Y6];
            const Yj = YY.prototype.show;
            if (typeof Yj !== "function") {
              {
                console.warn("[咸鱼助手][拦截器] 警告：" + Y6 + " 的 show 方法不存在，无法实现无感拦截。");
                return;
              }
            }
            YY.prototype.show = function () {
              {
                console.log("[咸鱼助手][拦截器] " + Y6 + " 尝试显示，已被无感拦截！");
                if (this.isShow) {
                  {
                    setTimeout(() => {
                      {
                        if (typeof this.close === "function") {
                          this.close();
                        } else {
                          if (typeof this.hide === "function") {
                            this.hide();
                          }
                        }
                      }
                    }, 0);
                  }
                }
                return Promise.resolve();
              }
            };
            console.log("[咸鱼助手][拦截器] 成功修改 " + Y6 + " 的 show 方法，实现无感拦截。");
          }
        } catch (Ys) {
          {
            Ys.message.includes("Cannot find module") ? console.warn("[咸鱼助手][拦截器] 警告：模块 " + Y6 + " 未找到，已跳过。") : console.error("[咸鱼助手][拦截器] 在修改 " + Y6 + " 过程中发生错误:", Ys);
          }
        }
      }
    },
    patchAllDialogs: function () {
      {
        if (this.isPatched || typeof unsafeWindow.__require !== "function") {
          return;
        }
        console.log("[咸鱼助手] 开始批量部署无感弹窗拦截...");
        console.log("[咸鱼助手] 当前拦截列表:", this.DIALOGS_TO_BLOCK);
        this.DIALOGS_TO_BLOCK.forEach(this.patchDialog);
        this.isPatched = true;
        console.log("[咸鱼助手] 所有目标弹窗拦截器已部署完毕。");
      }
    }
  };
  const r = {
    patched: false,
    patchModule: function () {
      {
        if (this.patched || !q) {
          {
            return;
          }
        }
        try {
          {
            if (typeof unsafeWindow.__require !== "function") {
              {
                return;
              }
            }
            const YY = unsafeWindow.__require("data-index");
            const Yj = YY.EMTeamType.nightMare;
            if (!YY || !YY.TeamService || typeof YY.TeamService.setTeam !== "function" || Yj === undefined) {
              {
                return;
              }
            }
            const YG = YY.TeamService.setTeam;
            console.log("[咸鱼助手][防同步] 已成功定位到原始的 TeamService.setTeam 方法。");
            YY.TeamService.setTeam = function (Yd) {
              {
                if (Yd && Yd.teamType === Yj) {
                  {
                    console.warn("[咸鱼助手][防同步] 拦截到“噩梦模式”的布阵同步请求，已阻止发送到服务器。");
                    console.log("[咸鱼助手][防同步] 拦截到的阵容数据:", Yd.battleTeam);
                    console.log("[咸鱼助手][防同步] 拦截到的武器ID:", Yd.lordWeaponId);
                    return Promise.resolve({
                      code: 0,
                      rawData: {},
                      getData: function () {
                        {
                          return {};
                        }
                      }
                    });
                  }
                }
                console.log("[咸鱼助手][防同步] 检测到非噩梦模式的布阵请求，已放行。类型: " + Yd.teamType);
                return YG.apply(this, arguments);
              }
            };
            this.patched = true;
            console.log("[咸鱼助手][十殿] 成功注入！十殿模式的布阵将不会同步到服务器。");
          }
        } catch (Yd) {}
      }
    }
  };
  let U = false;
  let A = false;
  let t = false;
  let J = false;
  let T = false;
  let D = false;
  let Y0 = false;
  let Y1 = false;
  let Y2 = false;
  const Y3 = setInterval(() => {
    if (typeof unsafeWindow.__require !== "function" || typeof unsafeWindow.fgui !== "object") {
      {
        return;
      }
    }
    const Y6 = U && A && t && J && T && D && Y0 && Y1 && Y2;
    if (Y6) {
      {
        clearInterval(Y3);
        console.log("[咸鱼助手] 所有模块已成功注入。脚本运行中...");
        return;
      }
    }
    !Y2 && (b.patchAllDialogs(), Y2 = b.isPatched);
    if (!U) {
      try {
        const YY = unsafeWindow.__require("MainPanel");
        YY && YY.MainPanel && (n.patchPanel(YY.MainPanel), U = true);
      } catch (Yj) {}
    }
    if (!A) {
      try {
        const YG = unsafeWindow.__require("BottleRobotDialog");
        YG && YG.BottleRobotDialog && (i.patchPanel(YG.BottleRobotDialog), A = true);
      } catch (YL) {}
    }
    if (!t) {
      try {
        const Ys = unsafeWindow.__require("BoxPanel");
        Ys && Ys.BoxPanel && (V.patchPanel(Ys.BoxPanel), t = true);
      } catch (Yd) {}
    }
    if (!J) {
      try {
        const Yy = "GVGRecordDialogNew";
        const Ym = unsafeWindow.__require(Yy);
        Ym && Ym[Yy] && (Z.patchPanel(Ym[Yy]), J = true);
      } catch (Yl) {}
    }
    if (!T) {
      try {
        const Yz = "LegionWarReportDialog";
        const YB = unsafeWindow.__require(Yz);
        YB && YB[Yz] && (a.patchDialog(YB[Yz]), T = true);
      } catch (YW) {}
    }
    !D && (O.patchModule(), D = O.patched);
    if (!Y0) {
      try {
        const YS = unsafeWindow.__require("QuenchStageUpDialog");
        YS && YS.QuenchStageUpDialog && (w.patchDialog(YS.QuenchStageUpDialog), Y0 = true);
      } catch (YR) {}
    }
    !Y1 && (r.patchModule(), Y1 = r.patched);
  }, 500);
})();